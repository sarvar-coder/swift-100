# SwiftProgramming
- I created this repo to master swift language. 
- So I will write 100 programs from simple to hardest. 
- inspired by [Rustam-z](https://github.com/Rustam-Z/cpp-programming?tab=readme-ov-file#problem-solving)

# Programs List. 

## LEVEL 1 — Swift Fundamentals (1–15)

Goal: fluency without thinking

1. Reverse a string **without using built-in reverse**
2. Check if a number is prime
3. Count vowels in a string
4. Find max/min in an array manually
5. Sum of odd numbers using `filter` + `reduce`
6. Remove duplicates from an array (no `Set`)
7. Fibonacci (iterative)
8. Factorial (recursive)
9. Check palindrome (string + number)
10. Find second largest element
11. Swap two numbers without temp variable
12. Count word frequency in a sentence
13. Merge two sorted arrays
14. Rotate array by `k` positions
15. Find missing number in `1...n`

> If you struggle here → your foundation is weak. No excuses.

---

## LEVEL 2 — Optionals, Enums, Structs (16–30)

Goal: think in Swift, not C-with-syntax

16. Safe division using `Optional`
17. Parse string to `Int?` with validation
18. Create enum-based calculator (`+ - * /`)
19. Model HTTP response using enum with associated values
20. Implement custom `Result` type
21. Create immutable `User` struct with validation
22. Compare two structs deeply
23. Write function returning multiple values via tuple
24. Model traffic light using enum + state transitions
25. Implement `Comparable` for custom struct
26. Parse CSV row into struct
27. Use `guard` to validate input pipeline
28. Write failable initializer
29. Build error hierarchy using `Error`
30. Convert raw JSON dictionary → strongly typed model

---

## LEVEL 3 — Protocols & Generics (31–45)

Goal: abstraction without overengineering

31. Protocol for `Shape` with area/perimeter
32. Generic stack (push/pop/peek)
33. Generic queue with FIFO
34. Protocol with associated type (DataSource)
35. Type-erased wrapper (`AnyShape`)
36. Generic sorting function with comparator
37. Protocol-oriented logging system
38. Implement `Equatable` manually
39. Strategy pattern using protocols
40. Dependency injection via protocol
41. Extend `Array` with safe subscript
42. Generic cache with expiration
43. Build custom `Sequence` & `Iterator`
44. Protocol default implementations
45. Compare inheritance vs protocol approach (code both)

> If you overuse classes here → you don’t understand Swift philosophy.

---

## LEVEL 4 — Collections & Algorithms (46–60)

Goal: algorithmic discipline

46. Binary search (generic)
47. Two-sum problem
48. Sliding window max sum
49. Longest common prefix
50. Detect cycle in array
51. Kadane’s algorithm
52. Anagram grouping
53. Intersection of two arrays (optimized)
54. Implement LRU cache
55. Kth largest element
56. Rotate matrix 90°
57. Merge intervals
58. Validate parentheses
59. Top K frequent elements
60. Implement Trie

> UIKit/SwiftUI won’t save you here.

---

## LEVEL 5 — Value vs Reference, ARC (61–70)

Goal: memory correctness

61. Demonstrate copy-on-write behavior
62. Class vs struct benchmark
63. Create retain cycle and fix it
64. Weak vs unowned example
65. Custom reference-counted object
66. Observer pattern (memory-safe)
67. Implement deep copy manually
68. Mutating vs non-mutating methods
69. Build graph with nodes (avoid leaks)
70. ARC debugging exercise

> If you can’t explain *why* something leaks, you don’t “know Swift”.

---

## LEVEL 6 — Concurrency & Async (71–80)

Goal: correctness under parallelism

71. Async network fetch simulation
72. Parallel map using `TaskGroup`
73. Rate-limited API caller
74. Thread-safe counter
75. Producer–consumer problem
76. Debounce user input
77. Cancelable async task
78. Retry logic with exponential backoff
79. Async cache with race protection
80. Deadlock scenario + fix

> `async/await` ≠ understanding concurrency.

---

## LEVEL 7 — Architecture & Design (81–90)

Goal: scalable thinking

81. MVVM counter app (logic only)
82. Clean Architecture use-case layer
83. Repository pattern with protocol
84. Offline-first data sync model
85. Feature flag system
86. Event bus implementation
87. Command pattern
88. State machine engine
89. Undo/redo system
90. Plugin-based architecture

> If everything depends on everything → bad design.

---

## LEVEL 8 — Expert / Painful (91–100)

Goal: mastery or ego death

91. JSON parser from scratch
92. Custom async task scheduler
93. Swift interpreter for mini language
94. Dependency graph resolver
95. Memory pool allocator
96. Diffing algorithm (like SwiftUI)
97. Reactive stream implementation
98. Mini SwiftUI-like layout engine
99. Actor-based banking system (race-free)
100. Write a Swift linter rule engine

---

## Brutal Truth (don’t skip)

If you **can’t comfortably solve 70+ of these**, you are **not “mastering Swift”** — you’re just productive.

To tell the truth it is by chatgpt. But I will do it.  
